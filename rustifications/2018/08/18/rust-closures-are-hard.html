<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Why Rust Closures are (Somewhat) Hard - Rustifications</title>
    <meta name="description" content="My Rustic Ramblings
">
    <link rel="alternate" type="application/rss+xml" title="Why Rust Closures are (Somewhat) Hard" href="/feed.xml" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/center-img.css">
    <link rel="canonical" href="https://stevedonovan.github.io/2018/08/18/rust-closures-are-hard.html">
    <link rel="shortcut icon" href="/favicon.ico">

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@StevedInJoburg" />
    <meta name="twitter:title" content="Why Rust Closures are (Somewhat) Hard" />
    
    <meta name="twitter:description" content="My Rustic Ramblings
" />
    
    <meta name="twitter:url" content="https://check-out-my-awesome-blog.org/2018/08/18/rust-closures-are-hard.html">

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/"><img id="site-logo" src="https://www.rust-lang.org/logos/rust-logo-64x64-blk.png"/> Rustifications</a>

    <!--<nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>-->

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Why Rust Closures are (Somewhat) Hard</h1>
    <p class="post-meta">Aug 18, 2018 • Steve Donovan</p>
  </header>

  <article class="post-content">
    <h2 id="the-easy-case-lua">The Easy Case: Lua</h2>

<p>Since hard is <em>always</em> relative to something else, I’d like to start with a
dynamic language. Functions in Lua are essentially <em>anonymous</em> and can
<em>capture</em> variables from their environment - much like with JavaScript, which Lua resembles
in several important ways):</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">m</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span>
<span class="kd">local</span> <span class="n">line</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="k">end</span>

<span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1">-- 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">-- 3</span>

<span class="k">function</span> <span class="nf">call</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="nb">print</span><span class="p">(</span><span class="n">call</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1">--3</span>
</code></pre>
</div>
<p>That’s cool and useful - we have created a function and <em>bound</em>
it to the variable <code class="highlighter-rouge">line</code>. These function values can be passed around,
since functions are <em>first class objects</em> in Lua:</p>

<p>Since functions are values, it is easy to write functions which return
functions - <em>higher-order functions</em>:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">make_line</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">function</span>
        <span class="nf">return</span> <span class="n">m</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">line</span> <span class="o">=</span> <span class="n">make_line</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">-- as before</span>
</code></pre>
</div>

<p>Rust closures are harder for three main reasons:</p>

<p>The first is that it is both statically and strongly typed, so
we’ll need to explicitly annotate these function types.</p>

<p>Second, Lua functions are dynamically allocated (‘boxed’.)
Rust does not allocate <em>silently</em> because it prefers
to be explicit and is a system language designed for maximally efficient code.</p>

<p>Third, closures share references with their environment.
In the case of Lua, the garbage collector ensures that these references
will <em>live long enough</em>. With Rust, the borrow checker needs
to be able to track the lifetimes of these references.</p>

<h2 id="the-easy-case-rust">The Easy Case: Rust</h2>

<p>The notation for Rust closures is very concise in comparison:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>

<span class="k">let</span> <span class="n">line</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">m</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="nf">line</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="nf">line</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</code></pre>
</div>
<p>Two points need emphasis. The first is that closures are quite distinct from
plain functions - I can define a function <code class="highlighter-rouge">line</code> here but it will <em>not</em> share
references to the local variables <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">c</code>. The second is that the argument
and return type are established by type inference.  As soon as we say <code class="highlighter-rouge">line(0.0)</code>
the compiler knows that this closure takes a <code class="highlighter-rouge">f64</code> and returns an <code class="highlighter-rouge">f64</code>. If I
subsequently try to call <code class="highlighter-rouge">line(1)</code> it will complain because no way Rust will
convert an integer into a float without a typecast.</p>

<p>Rust has a very similar attitude to C++ here - that closures should be a
<em>zero-overhead abstraction</em>.  Here we have a vector of integers, and wish to know
how many elements are greater than zero:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">my_vec</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="o">**</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.count</span><span class="p">();</span>
</code></pre>
</div>
<p>The guarantee is that this will be <em>just as fast</em> as writing out an explicit loop!
What is the type of <code class="highlighter-rouge">n</code>? <code class="highlighter-rouge">iter()</code> produces a iterator over references to the
elements (say <code class="highlighter-rouge">&amp;i32</code>) and <code class="highlighter-rouge">filter</code> takes a closure which is passed a reference to
the iterator type - so it will be <code class="highlighter-rouge">&amp;&amp;i32</code> in this case.  So we need a double dereference
to get the actual integer - Rust references don’t automagically dereference themselves,
except if a method is called. (A more idiomatic way of writing this is <code class="highlighter-rouge">|&amp;&amp;n| n &gt; 0</code>.)
So, although type inference saves us typing and makes iterator expressions much less noisy,
it does not not save us from having to know the type.</p>

<p>The way that Rust (and C++) avoids overhead in this most important case is
<em>not to box</em> closures. This means that they can be <em>inlined</em>.</p>

<h2 id="how-rust-closures-are-implemented">How Rust Closures are Implemented</h2>

<p>Our first little example is syntactical sugar for creating a struct:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SomeUnknownType</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">f64</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="n">SomeUnknownType</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// pseudo-code - note the 'call operator' is a _method_</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.m</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="k">self</span><span class="py">.c</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">SomeUnknownType</span><span class="p">{</span><span class="n">m</span><span class="p">:</span> <span class="o">&amp;</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="mf">2.0</span><span class="p">};</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.call</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="mf">3.0</span><span class="p">);</span>

</code></pre>
</div>
<p>The actual concrete type is not known to the
program. You will only see this type in error messages - here we use a common
trick to provoke <code class="highlighter-rouge">rustc</code> into telling us the actual type of the right-hand side:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>27 |     let f: () = |x| m*x + c;
   |                 ^^^^^^^^^^^ expected (), found closure
   |
   = note: expected type `()`
              found type `[closure@/home/steve/closure1.rs:27:17: 27:28 m:_, c:_]`

</code></pre>
</div>

<p>This a struct that <em>borrows references</em> to its environment and so must have a <em>lifetime</em>.</p>

<p>This is pretty much what happens with C++ lambdas, where the actual generated type
is unknown.  (This is one of the reasons why <code class="highlighter-rouge">auto</code> has become so important in
modern C++, because not all types can be expressed explicitly). With C++ one
has detailed control about what gets captured by reference or by copy; with Rust
by default everything is implicitly borrowed.</p>

<p>However, if we said <code class="highlighter-rouge">move |x| m*x + c</code> then the struct would look like this:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AnotherUnknownType</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">f64</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">AnotherUnknownType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.m</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="k">self</span><span class="py">.c</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The environment has been captured by <em>copying</em> <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">c</code> - no borrowing and
no lifetime associated with borrowing.</p>

<p>So there’s no magic involved with Rust closures - just sugar.</p>

<p>These are obviously very different types - what do they have in common?
They both match the trait bound <code class="highlighter-rouge">Fn(f64)-&gt;f64</code>.  Here is a generic function
which simply invokes the closure it has been given:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">invoke</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span>
<span class="n">where</span> <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>With Rust 1.26, there’s a simpler but completely equivalent notation:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">new_invoke</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Either way, the type bound for the <code class="highlighter-rouge">f</code> argument reads:
<code class="highlighter-rouge">f</code> is <em>any</em> type that implements <code class="highlighter-rouge">Fn(f64)-&gt;f64</code>.</p>

<p>Now, if we wanted to <em>store</em> closures, we have to box them. We can store
any functions matching <code class="highlighter-rouge">Fn(f64)-&gt;f64</code> as <code class="highlighter-rouge">Box&lt;Fn(f64)-&gt;f64&gt;</code>. A boxed closure
is also callable, but has a known fixed size because it is a pointer to the
closure struct, so you can put these boxes into a vector or a map.</p>

<p>It is equivalent to the <code class="highlighter-rouge">std::function</code> type in C++, which also involves
calling a <em>virtual method</em>.  <code class="highlighter-rouge">Box&lt;Fn(f64)-&gt;f64&gt;</code> is a Rust <em>trait object</em>.</p>

<p>These are three function traits in Rust, which correspond to the three kinds
of methods (remember that calling a closure is executing a method on a struct)</p>

<ul>
  <li><code class="highlighter-rouge">Fn</code>  call is <code class="highlighter-rouge">&amp;self</code> method</li>
  <li><code class="highlighter-rouge">FnMut</code> call is <code class="highlighter-rouge">&amp;mut self</code> method</li>
  <li><code class="highlighter-rouge">FnOnce</code> call is <code class="highlighter-rouge">self</code> method</li>
</ul>

<h2 id="implications-of-closures-are-structs">Implications of “Closures are Structs”</h2>

<p><code class="highlighter-rouge">|x| m*x + c</code> has a lifetime tied to that of <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">c</code>.
It cannot live longer than these variables.  The lifetime appears explictly
when we try to store closures in boxes:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">HasAClosure</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">closure</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span> <span class="o">+</span> <span class="err">'</span><span class="n">a</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="n">HasAClosure</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HasAClosure</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span>
    <span class="n">where</span> <span class="n">C</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span> <span class="o">+</span> <span class="err">'</span><span class="n">a</span> <span class="p">{</span>
        <span class="n">HasAClosure</span> <span class="p">{</span>
            <span class="n">closure</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>
<p>I recall being a little puzzled at the lifetime bound, until I fully internalized
the fact that closures are structs, and structs that borrow have lifetimes.</p>

<p>The borrow checker is going to be particularly strict about closures that borrow
mutably (<code class="highlighter-rouge">FnMut</code>) since there may be only one mutable reference to a value, and
that reference will be captured by the closure.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">change_x</span> <span class="o">=</span> <span class="p">||</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="nf">change_x</span><span class="p">();</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="err">....</span>
<span class="mi">25</span> <span class="p">|</span>     <span class="k">let</span> <span class="k">mut</span> <span class="n">change_x</span> <span class="o">=</span> <span class="p">||</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
   <span class="p">|</span>                    <span class="o">--</span> <span class="o">-</span> <span class="n">previous</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">due</span> <span class="n">to</span> <span class="k">use</span> <span class="n">of</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="n">in</span> <span class="n">closure</span>
   <span class="p">|</span>                    <span class="p">|</span>
   <span class="p">|</span>                    <span class="n">mutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>
<span class="mi">26</span> <span class="p">|</span>     <span class="nf">change_x</span><span class="p">();</span>
<span class="mi">27</span> <span class="p">|</span>     <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
   <span class="p">|</span>                   <span class="o">^</span> <span class="n">immutable</span> <span class="n">borrow</span> <span class="n">occurs</span> <span class="n">here</span>

</code></pre>
</div>
<p>The closure bound to <code class="highlighter-rouge">change_x</code> has got its sticky paws on <code class="highlighter-rouge">x</code> and will not release
it until it goes out of scope!  So this will work:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">change_x</span> <span class="o">=</span> <span class="p">||</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
    <span class="nf">change_x</span><span class="p">();</span>
<span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre>
</div>
<p>This is annoying, but it truly becomes a bastard when you have some struct keeping
actions as closures.
Only one of those actions can manipulate the environment! Working
with Rust is sometimes like the old joke about the person who goes to the doctor:
“It hurts when I do this”. To which the doctor replies, “Then don’t do it”. In the
case of actions that need to manipulate some state, make the owner of the actions
keep the state and explicitly pass a mutable reference to it in the actions. That is,
the closures themselves do not borrow mutably.</p>

<p>The problem goes beyond mutable references, particularly when the lifetime
of the closures has to be longer than any temporary scope. For instance, you may
attach an action to a button in some function - that action must last longer
than the function.</p>

<p><code class="highlighter-rouge">move</code> closures avoid borrow-checking problems by avoiding borrowing - they <em>move</em>
the values.  If those values are <code class="highlighter-rouge">Copy</code>, then Rust will copy.  But otherwise the value
will be moved and not be available afterwards. This is the only way to get
a closure with a <code class="highlighter-rouge">'static</code> lifetime.</p>

<p>A common strategy is to use shared references like
<code class="highlighter-rouge">Rc</code> and <code class="highlighter-rouge">Arc</code> (equivalent to C++’s <code class="highlighter-rouge">shared_ptr</code>). Cloning a shared reference just
increments the reference count, and dropping them decrements the count; when the count
goes to zero the actual value is dropped. This is a kind of garbage collection and
provides the important guarantee that the references will last ‘just long enough’. So typically
you would clone a reference and move it into a closure, and avoid explicit lifetime
problems.</p>

<h2 id="threads">Threads</h2>

<p>There is an intimate relationship between threads and closures - <code class="highlighter-rouge">std::thread::spawn</code> is
passed a closure and runs in a new thread. In this case, Rust insists that the closure has
a static lifetime, and usually we <code class="highlighter-rouge">move</code> the closure.</p>

<p>This isn’t an inherent feature of threads though! Consider <em>scoped threads</em> from the <strong>crossbeam</strong>
crate:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="nn">crossbeam</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">scope</span><span class="nf">.spawn</span><span class="p">(||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} thread!"</span><span class="p">,</span> <span class="n">greeting</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre>
</div>
<p>The spawned thread is <em>guaranteed</em> to be terminated by the end of the scope, and it is
<em>quite</em> happy with the lifetime of <code class="highlighter-rouge">greeting</code>, which lasts longer than the scope.</p>

<p>It gets better:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="nn">crossbeam</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">scope</span><span class="nf">.spawn</span><span class="p">(||</span> <span class="p">{</span>
        <span class="n">greeting</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" eh"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} thread!"</span><span class="p">,</span> <span class="n">greeting</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre>
</div>
<p>There’s no problem passing a mutable reference either. But, if you tried to mutate
the greeting in another thread within the scope you would get the usual “only one mutable
reference allowed” error. For sharing between threads you will still need <code class="highlighter-rouge">Arc</code>.</p>

<p>However, when declaring closures that need to run in another thread, you need to reassure
Rust that it is safe to do so.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">greeting</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">((</span><span class="nf">Fn</span><span class="p">()</span><span class="k">-&gt;</span><span class="o">&amp;</span><span class="err">'</span><span class="k">static</span> <span class="nb">str</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(||</span> <span class="s">"hello"</span><span class="p">);</span>
<span class="nn">crossbeam</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">scope</span><span class="nf">.spawn</span><span class="p">(||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">greeting</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} thread!"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre>
</div>
<p>Here <code class="highlighter-rouge">greeting</code> is a reference to any closure of no arguments that returns static strings.</p>

<p>The error is instructive:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>27 |         scope.spawn(|| {
   |               ^^^^^ `Fn() -&gt; &amp;str` cannot be shared between threads safely
   |
   = help: within `&amp;Fn() -&gt; &amp;str`, the trait `Sync` is not implemented for `Fn() -&gt; &amp;str`

</code></pre>
</div>

<p>And the problem goes away if we explicitly add this marker trait to the declaration:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">greeting</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">((</span><span class="nf">Fn</span><span class="p">()</span><span class="k">-&gt;</span><span class="o">&amp;</span><span class="err">'</span><span class="k">static</span> <span class="nb">str</span> <span class="o">+</span> <span class="n">Sync</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(||</span> <span class="s">"hello"</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="higher-order-functions">Higher-Order Functions</h2>

<p>These are less elegant than with Lua. Explicit type
annotations are a necessary part of life (if you want to remain sane.)</p>

<p>In the Bad Old Days, explicit boxing was your only option if you wanted to return a closure:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">old_adder</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">a1</span> <span class="o">=</span> <span class="nf">old_adder</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">a1</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="mf">3.0</span><span class="p">);</span>
</code></pre>
</div>
<p>Boxing is not always a bad choice, but it does make certain optimizations
impossible - like inlining the closure completely. (Note that the returned closure has
to be <code class="highlighter-rouge">move</code>, since any reference to the argument <code class="highlighter-rouge">a</code> is not going
to last longer than the body of <code class="highlighter-rouge">old_adder</code>. For a primitive like <code class="highlighter-rouge">f64</code>,
moving means copying.)</p>

<p>With Rust 1.26, you can say:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">new_adder</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span> <span class="p">{</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span>
<span class="p">}</span>
</code></pre>
</div>
<p>That is, <code class="highlighter-rouge">new_adder</code> returns a <em>particular</em> type, but all the caller needs know
is that it implements <code class="highlighter-rouge">Fn(f64)-&gt;f64</code>. In this case, even the callee doesn’t
know the exact type! Cleaner, and no boxing involved.</p>

<p><code class="highlighter-rouge">impl Trait</code> certainly helps with generic function signatures, although they
can still get a little unwieldy:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">compose</span> <span class="p">(</span><span class="n">f1</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">f64</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">f64</span> <span class="p">{</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="nf">f1</span><span class="p">(</span><span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">compose</span><span class="p">(</span><span class="nn">f64</span><span class="p">::</span><span class="n">sin</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="err">...</span>
</code></pre>
</div>
<p>Note that plain old functions match the same trait as closures.</p>

<p>These are already generic functions, since they are passed <em>any</em> type
that implements <code class="highlighter-rouge">Fn(f64)-&gt;f64</code>; for each unique type, a new implementation
is created - so-called <em>monomorphism</em> (the expression has the same shape,
but the generated code is different in each case.)</p>

<p>We can get even more generic, and define <code class="highlighter-rouge">compose</code> for any function
that maps a value to another value of that same type:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">compose</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">T</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">T</span> <span class="p">{</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="nf">f1</span><span class="p">(</span><span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>
<span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">compose</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim_left</span><span class="p">,</span> <span class="p">|</span><span class="n">s</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="err">..</span><span class="mi">2</span><span class="p">]);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">compose</span><span class="p">(</span><span class="s">" hello "</span><span class="p">),</span><span class="s">"h"</span><span class="p">);</span>
<span class="err">....</span>
</code></pre>
</div>
<p>Type inference is a marvelous thing - <code class="highlighter-rouge">compose</code> knows from the first argument that the
type parameter <code class="highlighter-rouge">T</code> must be <code class="highlighter-rouge">&amp;str</code> in this case.</p>

<p>An entertaining property of Rust generic functions is that the declaration is often more
scary than the implementation. C++ cheats with templates, since they are effectively
compile-time duck-typing. Easier to type, certainly, but the error messages can be less than helpful.</p>

<h2 id="summary-the-hardness-is-mostly-necessary">Summary: the Hardness is (Mostly) Necessary</h2>

<p>There’s always going to be some trade-off between programmer convenience
and performance. Rust would certainly be <em>easier</em> if it boxed closures and
used ‘smart pointer’ references by default, but it would not be Rust - in fact,
it would be similar to Swift. Instead, Rust aims for the same niche
occupied by C, C++ and Ada - predictable high performance and optimal use of
system resources (a “systems language”). The novelty it brings to that party
is explicitly enforcing lifetime analysis on references.</p>

<p>Closures make functional style possible, and Rust’s implementation makes
this efficient as possible. There is a lot less explicit looping needed,
and you (generally) don’t have to worry about the performance implications
of avoiding loops. Here Rust is following the ‘generic programming’
tradition of C++, where you don’t loop if the operation is already
provided by <code class="highlighter-rouge">&lt;algorithm&gt;</code> - the main difference is that <code class="highlighter-rouge">Iterator</code>
takes the place of iterator ranges and the operations are methods.</p>

<p>Closures are synthesized structs which either
borrow or move/copy their environment, very much like C++ lambdas.
The restrictions we’ve discussed follow directly from this implementation
and its interaction with the borrow checker.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <h2 class="footer-heading">Rustifications</h2>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/stevedonovan">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">stevedonovan</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/StevedInJoburg">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">StevedInJoburg</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">My Rustic Ramblings
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
