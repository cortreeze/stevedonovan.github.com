<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>The Common Rust Traits - Rustifications</title>
    <meta name="description" content="My Rustic Ramblings
">
    <link rel="alternate" type="application/rss+xml" title="The Common Rust Traits" href="/rustifications/feed.xml" />
    <link rel="stylesheet" href="/rustifications/css/main.css">
    <link rel="stylesheet" href="/rustifications/css/center-img.css">
    <link rel="canonical" href="https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html">
    <link rel="shortcut icon" href="/rustifications/favicon.ico">

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@StevedInJoburg" />
    <meta name="twitter:title" content="The Common Rust Traits" />
    
    <meta name="twitter:description" content="My Rustic Ramblings
" />
    
    <meta name="twitter:url" content="https://check-out-my-awesome-blog.org/2018/09/08/common-rust-traits.html">

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/rustifications/"><img id="site-logo" src="https://www.rust-lang.org/logos/rust-logo-64x64-blk.png"/> Rustifications</a>

    <!--<nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>-->

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">The Common Rust Traits</h1>
    <p class="post-meta">Sep 8, 2018 • Steve Donovan</p>
  </header>

  <article class="post-content">
    <h2 id="what-is-a-trait">What is a Trait?</h2>

<p>In Rust, data types - primitives, structs, enums and any other ‘aggregate’
types like tuples and arrays - are dumb. They may have methods but that
is just a convenience (they are just functions). Types have no
relationship with each other.</p>

<p><em>Traits</em> are the abstract mechanism for adding functionality to types
and establishing relationships between them.</p>

<p>They operate in two different modes; in their more familiar guise they act
like interfaces in Java or C# (and in fact the keyword <em>was</em> originally
<code class="highlighter-rouge">interface</code>).
Interface inheritance is supported, but not <em>implementation inheritance</em>.
There is <a href="https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html">support for object-orientated programming</a>
but it is different enough from the mainstream to cause conceptual confusion.</p>

<p>But, most characteristically, traits act as generic constraints. A generic function is
defined over types that implement specific traits.
That is, the “compile-time duck typing” of C++ templates is avoided. If we are passed a duck, then
it must implement <code class="highlighter-rouge">Duck</code>. The <code class="highlighter-rouge">quack()</code> method itself is not sufficient, as it is with Go.</p>

<h2 id="converting-things-to-strings">Converting Things to Strings</h2>

<p>To make this more concrete, consider <a href="https://doc.rust-lang.org/std/string/trait.ToString.html">ToString</a>
which defines a <code class="highlighter-rouge">to_string</code> method.
There are two ways to write functions taking references to types that implement it.</p>

<p>The first is <em>generic</em> or <em>monomorphic</em>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">string</span><span class="p">::</span><span class="n">ToString</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">to_string1</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">ToString</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">item</span><span class="nf">.to_string</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string1</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">42</span><span class="p">));</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string1</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"hello"</span><span class="p">));</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">item</code> is a reference to <em>any</em> type which implements <code class="highlighter-rouge">ToString</code>.</p>

<p>The second is <em>dynamic</em> or <em>polymorphic</em>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">to_string2</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ToString</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">item</span><span class="nf">.to_string</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string2</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">42</span><span class="p">));</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string2</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"hello"</span><span class="p">));</span>
</code></pre>
</div>
<p>Now, converting numbers and string slices to owned strings are obviously different operations.
In the first case, different code is generated for each distinct type, just like with a C++ template.
This is maximally efficient - <code class="highlighter-rouge">to_string</code> can be inlined.
In the second case, the code is generated once (it’s an ordinary function) but the actual
<code class="highlighter-rouge">to_string</code> is called dynamically. Here <code class="highlighter-rouge">&amp;ToString</code> is behaving much like a Java interface
or C++ base class with virtual methods.</p>

<p>A reference to a concrete type
becomes a trait object.  It’s non-trivial because the trait object
has two parts - the original reference and a ‘virtual method table’
containing the methods of the trait (a so-called “fat pointer”).</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">d</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Display</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">10</span><span class="p">;</span>
</code></pre>
</div>

<p>A little <em>too</em> much magic is happening here, and Rust is moving towards a
more explicit notation for trait objects, <code class="highlighter-rouge">&amp;dyn ToString</code> etc.</p>

<p>How to decide between generic and polymorphic?  The only honest answer is
“it depends”. Bear in mind that the actual cost of using trait objects
might be negligible compared to the other work done by a program.  (It’s hard
to make engineering decisions based on micro-benchmarks.)</p>

<h2 id="printing-out-display-and-debug">Printing Out: Display and Debug</h2>

<p>For a value to be printed out using <code class="highlighter-rouge"><span class="p">{}</span></code>, it must implement the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a> trait.
<code class="highlighter-rouge"><span class="p">{</span><span class="err">:?</span><span class="p">}</span></code> requires that it implement <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a>.</p>

<p>Defining <code class="highlighter-rouge">Display</code> for your own types is straightforward but needs to be
explicit, since the compiler cannot reasonably guess what the
output format must be (unlike with <code class="highlighter-rouge">Debug</code>)</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="c">// Debug can be auto-generated</span>
<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">MyType</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">u32</span>
<span class="p">}</span>

<span class="c">// but not Display</span>
<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">MyType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"x={},y={}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.x</span><span class="p">,</span> <span class="k">self</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">MyType</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">};</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="c">//=&gt; x=1,y=2</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="c">//=&gt; MyType { x: 1, y: 2 }</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">write!</code> macro is a relative of our friend <code class="highlighter-rouge">println!</code> where the first
parameter is anything that implements <code class="highlighter-rouge">Write</code> (more about this very important
trait later.)</p>

<p><code class="highlighter-rouge">Debug</code> is implemented by most standard library types and is a very convenient
way to get a developer-friendly string representation of your types. But note
that you have to ask for <code class="highlighter-rouge">Debug</code> to be implemented - Rust is not going to
make all structs pay the price of the extra code by default.</p>

<p>Any type that implements <code class="highlighter-rouge">Display</code> <em>automatically</em> implements <code class="highlighter-rouge">ToString</code>, so
<code class="highlighter-rouge">42.to_string()</code>, <code class="highlighter-rouge">"hello".to_string()</code> all work as expected.</p>

<p>(Rust traits often hunt in packs.)</p>

<h2 id="default">Default</h2>

<p>This expresses the intuitive idea that most types have a sensible default value,
like zero for numbers, empty for vectors, “” for <code class="highlighter-rouge">String</code>, etc.
Most standard library types
implement <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>.</p>

<p>Here is a roundabout way to declare an integer variable and set it to zero.
<code class="highlighter-rouge">default</code> is a generic method that returns some <code class="highlighter-rouge">T</code>, so Rust needs to know that
<code class="highlighter-rouge">T</code> somehow:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">n</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>  <span class="c">// declare type explicitly</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Default</code> is easy to implement for your own structs,
providing the type of each field implements <code class="highlighter-rouge">Default</code></p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Default</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">u16</span>
<span class="p">}</span>
<span class="err">..</span><span class="py">.
let</span> <span class="n">mine</span><span class="p">:</span> <span class="n">MyStruct</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
</code></pre>
</div>

<p>Rust likes to be explicit so this does not happen automatically, unlike in other
languages. If you said <code class="highlighter-rouge">let n: u64;</code> then Rust would expect a later initialization,
or complain bitterly.</p>

<p>There are no ‘named function parameters’ in Rust, but here is one idiom that achieves
the same thing. Imagine you have a function which could take a large number of
configuration arguments - that’s usually not a good idea, so you make up a big struct
called <code class="highlighter-rouge">Config</code>. If <code class="highlighter-rouge">Config</code> implements <code class="highlighter-rouge">Default</code>, then the function could be called
like so, without having to specify each and every field in <code class="highlighter-rouge">Config</code>.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="nf">my_function</span><span class="p">(</span><span class="n">Config</span> <span class="p">{</span>
    <span class="n">job_name</span><span class="p">:</span> <span class="s">"test"</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="p">:</span> <span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"/tmp"</span><span class="p">),</span>
    <span class="err">..</span><span class="py">.Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>
</div>

<h2 id="conversion-from-and-into">Conversion: From and Into</h2>

<p>An important pair of traits is <code class="highlighter-rouge">From/Into</code>. The <a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a>
trait expresses the conversion
of one value into another using the <code class="highlighter-rouge">from</code> method. So we have <code class="highlighter-rouge">String::from("hello")</code> .
If <code class="highlighter-rouge">From</code> is implemented, then the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a>
 trait is auto-implemented.</p>

<p>Since <code class="highlighter-rouge">String</code> implements <code class="highlighter-rouge">From&lt;&amp;str&gt;</code>, then <code class="highlighter-rouge">&amp;str</code> automatically implements <code class="highlighter-rouge">Into&lt;String&gt;</code>.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>  <span class="c">// From</span>
<span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.into</span><span class="p">();</span> <span class="c">// Into</span>
</code></pre>
</div>
<p>The <a href="https://docs.rs/json/0.11.13/json/">json</a> crate provides a nice example. A JSON object is indexed with strings,
and new fields can be created by inserting <code class="highlighter-rouge">JsonValue</code> values:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">obj</span><span class="p">[</span><span class="s">"surname"</span><span class="p">]</span> <span class="o">=</span> <span class="nn">JsonValue</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Smith"</span><span class="p">);</span> <span class="c">// From</span>
<span class="n">obj</span><span class="p">[</span><span class="s">"name"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Joe"</span><span class="nf">.into</span><span class="p">();</span> <span class="c">// Into</span>
<span class="n">obj</span><span class="p">[</span><span class="s">"age"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">35</span><span class="nf">.into</span><span class="p">();</span> <span class="c">// Into</span>
</code></pre>
</div>
<p>Note how convenient it is to use <code class="highlighter-rouge">into()</code> here, instead of using <code class="highlighter-rouge">from()</code>. We are doing
a conversion which Rust will not do implicitly. But <code class="highlighter-rouge">into()</code> is a small word,
easy to type and read.</p>

<p><code class="highlighter-rouge">From</code> expresses a conversion that <em>always</em> succeeds. It may be relatively expensive, though:
converting a string slice to a <code class="highlighter-rouge">String</code> will allocate a buffer and copy the bytes. The
conversion always takes place by value.</p>

<p><code class="highlighter-rouge">From/Info</code> has an intimate relationship with Rust error handling.</p>

<p>This statement in a function returning <code class="highlighter-rouge">Result&lt;T,E&gt;</code>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">returns_some_result</span><span class="p">()</span><span class="err">?</span><span class="p">;</span>
</code></pre>
</div>
<p>is (in effect) sugar for this:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="nf">returns_some_result</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="p">,</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="nf">.into</span><span class="p">())</span>
<span class="p">};</span>
</code></pre>
</div>
<p>That is, any error type which can convert <em>into</em> the returned error type <code class="highlighter-rouge">E</code> works.</p>

<p>A useful strategy for informal error handling is to make the function return
<code class="highlighter-rouge">Result&lt;T,Box&lt;Error&gt;&gt;</code>.  Any type that implements <code class="highlighter-rouge">Error</code> can be converted
into the trait object <code class="highlighter-rouge">Box&lt;Error&gt;</code>.</p>

<h2 id="making-copies-clone-and-copy">Making Copies: Clone and Copy</h2>

<p><code class="highlighter-rouge">From</code> (and its mirror image <code class="highlighter-rouge">Into</code>) describe how distinct types are converted into
each other. <code class="highlighter-rouge">Clone</code> describes how a new value of the same type can be created.
Rust likes to make any potentially expensive operation obvious, so <code class="highlighter-rouge">val.clone()</code>.</p>

<p>This can simply involve moving some bits around (“bitwise copy”).
A number is just a bit pattern in memory.</p>

<p>But <code class="highlighter-rouge">String</code> is different, since as well as size and capacity fields,
it has dynamically-allocated string data. To clone a string involves
allocating that buffer and copying the original bytes into it. There’s <em>depth</em>
to the clone operation here.</p>

<p>Making your types cloneable is easy, as long as every type in a struct or enum
implements <code class="highlighter-rouge">Clone</code>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Debug</span><span class="p">,</span><span class="n">Clone</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">first_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">last_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Copy</code> is a <em>marker trait</em> (there are no methods to implement) which says that
a type may be copied by just moving bits. You can define it for your own
structs:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Debug</span><span class="p">,</span><span class="n">Clone</span><span class="p">,</span><span class="nb">Copy</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">f32</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Again, only possible if all types implement <code class="highlighter-rouge">Copy</code>. You cannot sneak in a
non-<code class="highlighter-rouge">Copy</code> type like <code class="highlighter-rouge">String</code> here!</p>

<p>This trait interacts with a key Rust feature: moving. Moving a value is always
done by simply moving bits around.  If the value is <code class="highlighter-rouge">Copy</code>, then the original
location remains valid. (The implication is that copying is <em>always bitwise</em>.)</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span>
<span class="c">// n1 is still fine (i32 is Copy)</span>
<span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
<span class="c">// value moved into s2, s1 can no longer be used!</span>
</code></pre>
</div>
<p>Bad things would happen if <code class="highlighter-rouge">s1</code> was still valid - both <code class="highlighter-rouge">s1</code> and <code class="highlighter-rouge">s2</code> would
be dropped at the end of scope and their shared buffer would be deallocated twice!
C++ handles this situation by always copying; in Rust you
must say <code class="highlighter-rouge">s1.clone()</code>.</p>

<h2 id="fallible-conversions---fromstr">Fallible Conversions - FromStr</h2>

<p>If I have the integer <code class="highlighter-rouge">42</code>, then it is safe to convert this to an owned string,
which is expressed by <code class="highlighter-rouge">ToString</code>.  However, if I have the string “42” then
the conversion into <code class="highlighter-rouge">i32</code> must be prepared to fail.</p>

<p>To implement <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr</a>
takes two things; defining the <code class="highlighter-rouge">from_str</code> method
and setting the associated type <code class="highlighter-rouge">Err</code> to the error type returned when the conversion fails.</p>

<p>Usually it’s used implicitly through the string <code class="highlighter-rouge">parse</code> method. This is a method with
a generic output type, which needs to be tied down.</p>

<p>E.g. using the turbofish operator:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">match</span> <span class="s">"42"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="p">,</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"'42' was not 42!"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Or (more elegantly) in a context where we can use <code class="highlighter-rouge">?</code>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">answer</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="s">"42"</span><span class="nf">.parse</span><span class="p">()</span><span class="err">?</span><span class="p">;</span>
</code></pre>
</div>

<p>The Rust standard library defines <code class="highlighter-rouge">FromStr</code> for the numerical types and for network addresses.
It is of course possible for external crates to define <code class="highlighter-rouge">FromStr</code> for their types and then
they will work with <code class="highlighter-rouge">parse</code> as well.  This is a cool thing about the standard traits - they
are all open for further extension.</p>

<h2 id="reference-conversions---asref">Reference Conversions - AsRef</h2>

<p><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef</a> expresses the situation where a cheap <em>reference</em> conversion is possible
between two types.</p>

<p>The most common place you will see it in action is with <code class="highlighter-rouge">&amp;Path</code>. In an ideal world,
all file systems would enforce UTF-8 names and we could just use <code class="highlighter-rouge">String</code> to
store them. However, we have not yet arrived at Utopia and Rust has a dedicated
type <code class="highlighter-rouge">PathBuf</code> with specialized path handling methods, backed by <code class="highlighter-rouge">OsString</code>,
which represents untrusted text from the OS. <code class="highlighter-rouge">&amp;Path</code> is the borrowed counterpart
to <code class="highlighter-rouge">PathBuf</code>. It is cheap to get a <code class="highlighter-rouge">&amp;Path</code> reference from regular Rust strings
so <code class="highlighter-rouge">AsRef</code> is appropriate:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// asref.rs</span>
<span class="k">fn</span> <span class="nf">exists</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">p</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.exists</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nf">exists</span><span class="p">(</span><span class="s">"asref.rs"</span><span class="p">));</span>
<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nf">exists</span><span class="p">(</span><span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"asref.rs"</span><span class="p">)));</span>
<span class="k">let</span> <span class="n">ps</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"asref.rs"</span><span class="p">);</span>
<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nf">exists</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="p">));</span>
<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nf">exists</span><span class="p">(</span><span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"asref.rs"</span><span class="p">)));</span>
</code></pre>
</div>

<p>This allows any function or method working with file system paths to be conveniently
called with any type that implements <code class="highlighter-rouge">AsRef&lt;Path&gt;</code>.  From the documentation:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Path</span>
<span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">OsStr</span>
<span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">OsString</span>
<span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">str</span>
<span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">String</span>
<span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PathBuf</span>
</code></pre>
</div>

<p>Follow this pattern when defining a public API, because people are accustomed to
this little convenience.</p>

<p><code class="highlighter-rouge">AsRef&lt;str&gt;</code> is implemented for <code class="highlighter-rouge">String</code>, so we can also say:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_hello</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="k">impl</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">());</span>
<span class="p">}</span>

<span class="nf">is_hello</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nf">is_hello</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
</code></pre>
</div>
<p>This seems attractive, but using this is very much a matter of taste. Idiomatic Rust code
prefers to declare string arguments as <code class="highlighter-rouge">&amp;str</code> and lean on <em>deref coercion</em>
for convenient passing of <code class="highlighter-rouge">&amp;String</code> references.</p>

<h2 id="overloading----deref">Overloading <code class="highlighter-rouge">*</code> - Deref</h2>

<p>Many string methods in Rust are not actually defined on <code class="highlighter-rouge">String</code>. The methods
explicitly defined typically <em>mutate</em> the string, like <code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">push_str</code>.
But something like <code class="highlighter-rouge">starts_with</code> applies to string slices as well.</p>

<p>At one point in Rust’s history, this had to be done explicitly, so if you
had a <code class="highlighter-rouge">String</code> called <code class="highlighter-rouge">s</code>, you would have to say <code class="highlighter-rouge">s.as_str().starts_with("hello")</code>.
You will occasionally see <code class="highlighter-rouge">as_str()</code>, but mostly method resolution happens
through the magic of <em>deref coercion</em>.</p>

<p>The <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> trait is actually used to implement the “dereference” operator <code class="highlighter-rouge">*</code>.
This has the same meaning as in C - extract the value which the reference is
pointing to - although doesn’t appear explicitly as much. If <code class="highlighter-rouge">r</code> is a reference,
then you say <code class="highlighter-rouge">r.foo()</code>, but if you did want the value, you have to say <code class="highlighter-rouge">*r</code>
(In this respect Rust references are more like C pointers than C++ references,
which try to be behave like C++ values, leading to hidden differences.)</p>

<p>The most obvious use of <code class="highlighter-rouge">Deref</code> is with “smart pointers” like <code class="highlighter-rouge">Box&lt;T&gt;</code>
and <code class="highlighter-rouge">Rc&lt;T&gt;</code> - they <em>behave</em> like references to the values inside them,
so you can call methods of <code class="highlighter-rouge">T</code> on <code class="highlighter-rouge">Box&lt;T&gt;</code> and so forth.</p>

<p><code class="highlighter-rouge">String</code> implements <code class="highlighter-rouge">Deref</code>; kf <code class="highlighter-rouge">s</code> is <code class="highlighter-rouge">String</code> then the type of <code class="highlighter-rouge">&amp;*s</code> is <code class="highlighter-rouge">&amp;str</code>.</p>

<p>Deref coercion means that <code class="highlighter-rouge">&amp;String</code> will implicitly convert into <code class="highlighter-rouge">&amp;str</code>:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.into</span><span class="p">();</span>
<span class="k">let</span> <span class="n">rs</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
</code></pre>
</div>
<p>“Coercion” is a strong word, but this is one of the few places in Rust
where type conversion happens silently. <code class="highlighter-rouge">&amp;String</code> is a very
different type to <code class="highlighter-rouge">&amp;str</code>! I still remember my
confusion when the compiler insisted that these types were distinct,
especially with operators where the convenience of deref coercion
does not happen.  The match operator matches types explicitly
and this is where <code class="highlighter-rouge">s.as_str()</code> is still necessary - <code class="highlighter-rouge">&amp;s</code> would not work here:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>let s = "hello".to_string();
...
match s.as_str() {
    "hello" =&gt; {....},
    "dolly" =&gt; {....},
    ....
}
</code></pre>
</div>

<p>It’s idiomatic to use string slices in function arguments, knowing that
<code class="highlighter-rouge">&amp;String</code> will convert to <code class="highlighter-rouge">&amp;str</code>.</p>

<p>Deref coercion is also used to resolve methods - if the method isn’t defined
on <code class="highlighter-rouge">String</code>, then we try <code class="highlighter-rouge">&amp;str</code>.  It acts like a limited kind of inheritance.</p>

<p>A similar relationship holds between <code class="highlighter-rouge">Vec&lt;T&gt;</code> and <code class="highlighter-rouge">&amp;[T]</code>. Likewise, it’s
not idiomatic to have <code class="highlighter-rouge">&amp;Vec&lt;T&gt;</code> as a function argument type, since <code class="highlighter-rouge">&amp;[T]</code>
is more flexible and <code class="highlighter-rouge">&amp;Vec&lt;T&gt;</code> will convert to <code class="highlighter-rouge">&amp;[T]</code>.</p>

<h2 id="ownership-borrow">Ownership: Borrow</h2>

<p>Ownership is an important concept in Rust; we have types like <code class="highlighter-rouge">String</code> that
“own” their data, and types like <code class="highlighter-rouge">&amp;str</code> that can “borrow” data from
an owned typed.</p>

<p>The <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">Borrow</a>
trait solves a sticky problem with associative maps and sets.
Typically we would keep owned strings in a <code class="highlighter-rouge">HashSet</code> to avoid borrowing blues.
But we really don’t want to <em>create</em> a <code class="highlighter-rouge">String</code> to query set membership!</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"one"</span><span class="nf">.to_string</span><span class="p">());</span>
<span class="c">// set is now HashSet&lt;String&gt;</span>
<span class="k">if</span> <span class="n">set</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"two"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"got two!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The borrowed type <code class="highlighter-rouge">&amp;str</code> can be used instead of <code class="highlighter-rouge">&amp;String</code> here.</p>

<h2 id="io-read-and-write">I/O: Read and Write</h2>

<p>The types <code class="highlighter-rouge">std::fs::File</code> and <code class="highlighter-rouge">std::io::Stdin</code> are very distinct. Rust does not
hack stdin as a kind-of file.  What they <em>do</em> share is the trait <a href="https://doc.rust-lang.org/std/io/trait.Read.html">Read</a>.</p>

<p>The basic method <code class="highlighter-rouge">read</code> will read some bytes into a buffer and return <code class="highlighter-rouge">Result&lt;usize&gt;</code>.
If there was not an error, this will be the number of bytes read.</p>

<p><code class="highlighter-rouge">Read</code> provides the method <code class="highlighter-rouge">read_to_string</code> which will read <em>all</em> of a file in
as a <code class="highlighter-rouge">String</code>, or <code class="highlighter-rouge">read_to_end</code> which reads the file as <code class="highlighter-rouge">Vec&lt;u8&gt;</code>. (If a file
isn’t guaranteed to be UTF-8, it’s better to use <code class="highlighter-rouge">read_to_end</code>.)</p>

<p>Traits need to be visible to be used, but <code class="highlighter-rouge">Read</code> is not part of the Rust prelude.
Instead <code class="highlighter-rouge">use std::io::prelude::*</code> to get all of the I/O traits in scope.</p>

<p>An important thing to remember is that Rust I/O is unbuffered by default.
So a naive Rust program can be outperformed by a script!</p>

<p>For instance, if you want the fastest possible way to read from stdin,
lock it first - the currently executing thread now has exclusive access:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">stdin</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">lockin</span> <span class="o">=</span> <span class="n">stdin</span><span class="nf">.lock</span><span class="p">();</span>
<span class="c">// lockin is buffered!</span>
</code></pre>
</div>
<p>Locked stdin implements <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">ReadBuf</a> which defines buffered reading.
There is a <code class="highlighter-rouge">lines()</code> method which iterates over all lines in the input, but
it allocates a new string for each line, which is convenient but inefficient.
For best performance, use <code class="highlighter-rouge">read_line</code> because it allows you to reuse a
single string buffer.</p>

<p>Likewise, to get buffered reading from a file:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">rdr</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="n">BufReader</span><span class="p">:</span><span class="nf">new</span><span class="p">(</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="err">?</span><span class="p">);</span>
<span class="err">...</span>
</code></pre>
</div>
<p>This comes across as unnecessarily fiddly at first but bear in mind that Rust
is a systems language which aims to make things like buffering and allocation explicit.</p>

<p>For writing, there is the <a href="https://doc.rust-lang.org/std/io/trait.Write.html">Write</a> trait. Files, sockets and standard streams like
stdout and stderr implement this.  Again, this is unbuffered and <code class="highlighter-rouge">io::BufWriter</code> exists
to add buffering to any type that implements <code class="highlighter-rouge">Write</code>.</p>

<p>There is a performance cost with the <code class="highlighter-rouge">println</code> macro. It is
designed for convenient and sensible output, not for speed. It gets an exclusive lock
before writing out so you do not get scrambled text from different threads.
So, if you need fast, buffer and use the <code class="highlighter-rouge">write</code> macro.</p>

<h2 id="iteration-iterator-and-intoiterator">Iteration: Iterator and IntoIterator</h2>

<p>The <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a> trait is interesting.
You are only required to implement
one method - <code class="highlighter-rouge">next()</code> - and all that method must do is return an
<code class="highlighter-rouge">Option</code> value each time it’s called. When that value is <code class="highlighter-rouge">None</code> we
are finished.</p>

<p>This is the verbose way to use an iterator:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span><span class="nf">.iter</span><span class="p">();</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"got {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code class="highlighter-rouge">for</code> statement provides a shortcut:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="n">n</span> <span class="n">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"got {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The expression here actually is <em>anything that can convert into an iterator</em>,
which is expressed by <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a>.
So <code class="highlighter-rouge">for n in &amp;[10, 20, 30] {...}</code> works
as well - a slice is definitely not an iterator, but it implements
<code class="highlighter-rouge">IntoIterator</code>.  Iterators implement <code class="highlighter-rouge">IntoIterator</code>
(trivially).</p>

<p>So the <code class="highlighter-rouge">for</code> statement in Rust is specifically tied to a single trait.</p>

<p>Iterators in Rust are a zero-overhead abstraction, which means that <em>usually</em>
you do not pay a run-time penalty for using them. In fact, if you wrote out
a loop over slice elements explicitly it would be slower because
of the run-time index range checks.</p>

<p>There are a lot of <em>provided</em> methods which have default
implementations in <code class="highlighter-rouge">Iterator</code>. You get <code class="highlighter-rouge">map</code>,<code class="highlighter-rouge">filter</code>,etc for free.
I advise people to familiarize themselves with these methods because they are
very useful. Often you do not need an explicit loop at all.
For instance, this is the idiomatic way to sum a sequence of numbers,
and there is no performance penalty whatsoever.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">res</span><span class="p">:</span> <span class="nb">i64</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="err">.</span><span class="py">.n</span><span class="p">)</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>
</code></pre>
</div>

<p>The most general way to pass a sequence of values to a function is
to use <code class="highlighter-rouge">IntoIterator</code>. Just using <code class="highlighter-rouge">&amp;[T]</code> is too limited and requires the caller
to build up a buffer (which could be both awkward and expensive), <code class="highlighter-rouge">Iterator&lt;Item=T&gt;</code>
itself requires caller to call <code class="highlighter-rouge">iter()</code> etc.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sum</span> <span class="p">(</span><span class="n">ii</span><span class="p">:</span> <span class="k">impl</span> <span class="n">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="n">ii</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">sum</span><span class="p">(</span><span class="mi">0</span>..<span class="mi">9</span><span class="p">));</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">sum</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]));</span>
<span class="c">// cloned() here makes an interator over i32 from an interator over &amp;i32</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()));</span>
</code></pre>
</div>

<h2 id="conclusion-why-are-there-so-many-ways-to-create-a-string">Conclusion: Why are there So Many Ways to Create a String?</h2>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">();</span>  <span class="c">// ToString</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span> <span class="c">// From</span>
<span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.into</span><span class="p">();</span> <span class="c">// Into</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_owned</span><span class="p">();</span>  <span class="c">// ToOwned</span>
</code></pre>
</div>
<p>This is a common complaint - people like to have one idiomatic way of
doing common operations.  And (curiously enough) none of these are actual
<code class="highlighter-rouge">String</code> methods!</p>

<p>But all these traits are needed, since they make generic programming possible;
when you create strings in code, just pick one way and use it consistently.</p>

<p>A consequence of Rust’s dependence on traits is that it can take a while
to <a href="https://stevedonovan.github.io/rust-gentle-intro/5-stdlib-containers.html">learn to read the documentation</a>.
Knowing what methods can be called on a type depends on what traits are implemented for that type.
<code class="highlighter-rouge">std::fs::File</code> doesn’t have any methods to actually <em>do</em> I/O - these capabilities come from
implementing <code class="highlighter-rouge">Read</code> and <code class="highlighter-rouge">Write</code>.</p>

<p>However, Rust traits are not sneaky. They have to be brought into scope before they
can be used. For instance, you need <code class="highlighter-rouge">use std::error::Error</code> before you can
call <code class="highlighter-rouge">description()</code> on a type implementing <code class="highlighter-rouge">Error</code>. The Rust <em>prelude</em> brings in
many common traits so they do not need to be explicitly brought into scope.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <h2 class="footer-heading">Rustifications</h2>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/stevedonovan">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">stevedonovan</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/StevedInJoburg">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">StevedInJoburg</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">My Rustic Ramblings
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
